---
title: Java基础03面向对象
date: 2017-01-12 08:30:00
categories: Java
tags: Java基础
description: 了解面向过程编程思想，能够通过案例理解Java的面向对象编程思想，了解面向对象开发、设计、特征。

---

# 面向对象上
## 面向对象的概述
1. 面向对象的概述：面向对象是一种符号人类思维习惯的编程思想，现实生活中存在各种形态不同的事物，这些事物之间存在着各种各样的联系，程序中使用对象来映射事物，使用对象的关系来描述事物之间的关系，这种思想就是面向对象；
2. 面向对象的特点：封装性、继承性和多态性；
3. 面向对象与面向过程的区别：面向过程就是分析解决问题的所需要的步骤，然后用函数把这些步骤一一是实现，使用的时候一个一个一次调用就可以了。面向对象则是把解决问题按照一定的规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。
4. Private关键字：所谓类的封装是指在定义一个类时，将类中的属性私有化，使用关键字private来修饰，私有属性只能在类中被访问。为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法，隐藏实现的细节，提供公共的访问方式；
## 类和对象
1. 类是对象的抽象，类是描述一组对象共同特征和行为；
2. 对象是事物的具体化，类的实例化就是对象，对象是具体的表现形式；
## 构造函数
1. 特点：方法名和类名一样，没有返回值类型，没有具体的返回值；
2. 注意事项：如果在创建一个类的时候，没有自定义一个构造方法，则系统会默认创建一个无参空构造方法。如果在创建一个类的时候，有自定义了构造方法，则系统不创建构造方法；
3. 由于有时候需要创建不同的构造方法，而系统不再创建无参空构造方法，因此建议手动创建一个无参空构造方法。
## this关键字
1. 概述：是一个关键字。代表当前对象的引用。在非静态方法中，this指的是调用方法的对象。那个对象调用了方法，this就代表那个对象。
2. 应用场景：解决局部变量隐藏成员变量问题、成员方法中调用其他成员方法、在构造方法中调用其他构造方法；
## static关键字
1. 概述：是一个关键字。可以修饰成员变量和方法。
2. 特点：随着类的加载而加载、优先于对象存在、被类的所有对象所共享、可以通过类名调用；
3. 注意事项：在静态方法中不能使用this关键字、静态方法只能调用静态方法和静态成员；
## 代码块
1. 代码块的概述：没有名称使用一对大括号括住的代码称为代码块；
2. 静态代码块：前面加上static修饰的代码块，存在类中方法上。作用：加载驱动器；
3. 构造代码块：作用：构造方法共性提取，存在类中方法上。可以给所有对象进行初始化；
4. 局部代码块：作用：存在方法中。控制变量的生命周期；
5. 代码块调用和执行的顺序：
调用：子类构造函数 ---- 子类构造代码块 ---- 父类构造函数 ----- 父类构造代码块   静态代码块随着类的加载而加载；
执行：父类静态代码块—子类静态代码块—父类构造代码块—父类构造函数—子类构造代码块---子类构造函数
## 内部类
1. 内部类的概念：将一个类定义在另外一个类的里面，对里面那个类就称为内部类。内部类的出现再次打破了Java单一继承的局限性。由于内部类都是在类中，因此它是类的成员，对类成员适用的修饰符也适合修饰内部类。
调用：外部类.内部类 变量名=new 外部类().new 内部类();
2. 成员内部类：定义在类中方法外；
3. 静态内部类：定义在类中方法外，适用static修饰；
访问：外部类名.内部类名 对象名 = 外部类名.new 内部类();或外部类名.内部类名.成员
4. 局部内部类：定义在方法中的类；
5. 匿名内部类：定义在方法中的类；可以在其后面调用方法或者直接作为参数进行传递；
格式：

	new Object(){
		void method(){
			System.out.println("method run");
		}
	}.method();

## Java帮助文档
1. 类使用：注意包名、版本号、构造方法、字段、成员方法；
2. 方法使用：左侧：修饰符、static、返回值类型；右侧：方法名、参数列表
3. 生成注释文档：javadoc –d . –version –author Hello.java
 
# 面向对象下
## 继承
1. 继承的概念：现实生活中继承一般指的是子女从父辈中继承财产。程序中继承用来描述事物之间的所属关系。把多个类中的相同属性和行为进行抽取，封装到一个类中，然后再建立新的类的时候，不需要从头做起，继承封装好的类即可。
2. 继承的特点：单一继承、多重继承；
## super关键字
1. 概念：super是一个关键字，代表父类的存储空间标识；
2. 应用场景：解决子类变量隐藏父类变量问题、成员方法中调用父类成员方法、在子类构造方法中调用父类构造方法；
3. super和this的区别：成员方法：this用于显示被局部变量隐藏的成员变量。Super用于调用父类的成员变量；成员方法：this在本类非静态方法中调用其他成员方法。Super在子类非静态方法中调用父类的方法；构造方法：this在子类的构造方法中调用其他构造方法。Super在子类构造方法中调用父类构造方法；
## final关键字
1. 是一个关键字，用于修饰类、成员变量和成员方法；
2. 特点：修饰的类为最终类，不能被继承；修饰的方法为最终方法，不能被重写；修饰的变量是常量；
## 抽象类和接口
1. 抽象类的概念：如果多个类中存在相同的方法声明，而方法体不一样，我们就可以只提取方法声明。如果一个方法只有方法声明，没有方法体，那么这个方法必须是抽象方法使用abstract修饰，而一个类中如果有抽象方法是，必须定义为抽象类。
抽象类的特点：抽象类和抽象方法必须用abstract修饰、抽象类不能被实例化、抽象类中有构造方法用于子类实例化使用、如果一个类继承了抽象类，那个继承它的子类要么是抽象类，要么抽象所有抽象方法。
2. 接口的概念：如果一个抽象类中的所有方法都是抽象方法，这个时候就可以将这个类用另外一种方式来定义，即接口。
接口的特点：接口默认修饰符为public abstract、接口中方法默认修饰public abstract修饰、接口中的成员默认public final static修饰、接口不能被实例化、一个类实现了接口，要么是抽象类，要么实现接口中的所有方法；
3. 抽象类和接口的区别：成员变量：抽象类中可以有成员变量和常量。接口中只能有常量；成员方法：抽象类中可以抽象方法和非抽象方法。接口只能有抽象方法；构造方法：抽象类中有构造方法。接口中没有构造方法；与类的关系：抽象类与类的关系是继承。接口与类的关系是实现。
## 多态
1. 多态的概念：对象的不同时刻表现出来的不同状态；或者某一事物的多做存在形态。
2. 多态的前提：要有继承或实现关系；要有方法重写或实现；父类引用或父接口引用指向子类对象；
3. 多态特点：成员变量：编译是看左边，运行时看右边；成员方法：编译时看左边，运行时看右边；
4. 多态的利和弊：弊：父类引用不能使用子类特有成员；利：提高代码的扩展性和可维护性；
5. 修饰符权限：private本类中使用、默认修饰符同一包下使用、protected不同包下子类使用、public任意地方；
6. 修饰符使用规范：所有的类都用public修饰，并且一个类写一个Java文件、所有成员变量使用private修饰、所有成员方法用public修饰（不需要外界访问的可以使用private修饰）如果是接口和抽象类使用public abstract、所有构造方法使用public，如果是工具类或者单例类构造使用private修饰。
## 异常
1. Throwable

	|--Error 错误：严重的问题，是处理不了的。要改正代码的。
	|--Exception 非RuntimeException编译时异常：是需要处理的。编译期异常。
		|--RuntimeException 运行时异常：不需要处理的，是需要改代码的。运行期异常。

2. 异常处理方案：
自己处理：try...catch...catch…finally
抛出处理：用throws关键字在方法上声明(抛出)。
3. 异常处理方式：
异常前处理： 不让异常发生
异常后处理：提前把想好的错误可能，并作出相应的措施；
4. 异常处理种类：
系统定义异常：系统提供的异常
自定义异常：自己定义异常
5. Exception和RuntimeException的区别
Exception 编译时期异常，必须处理的。如果在方法上，throws了该类型的异常，将来调用者必须处理。如果在方法内部，throw了该类型的异常，必须在方法上throws该异常。
RuntimeException 运行时期异常，是不需要处理的。要改代码的。如果在方法上，throws了该类型的异常，不需要处理。

6. throw和throws的用法和区别
throw
用法：用在方法内部，后面跟的是异常对象名称。
区别：用throw抛出了编译时期异常，方法上面必须用throws抛出。
用throw抛出了运行时期异常，方法上面可以不用throws抛出。
throws
用法：用在方法声明上，后面跟的是异常类名。
区别：用throws在方法上声明了异常，内部可以没有throw
## 包
1. 声明包：package com.jjdxm.example
2. 引用包或导入包：import com.jjdxm.Animal;
3. 编译：javac -d . hellojava.java    
4. 运行：java com.jjdxm.dog  
5. 打包jar -cvf hellojava.jar com  
6. 解包jar -xvf hellojava.jar   修改MANIFEST.MF添加Main-Class: com.jjdmx.dog
7. 运行包java -jar hellojava.jar 
 
